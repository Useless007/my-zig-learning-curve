# Control Flow ใน Zig

Control flow คือโครงสร้างของภาษาโปรแกรมมิ่งที่กำหนดลำดับการทำงานของโค้ด ใน Zig มีโครงสร้างควบคุมหลายแบบที่ช่วยให้เราสามารถเขียนโปรแกรมที่มีความยืดหยุ่นและมีประสิทธิภาพ

## 1. if และ else

`if` และ `else` ใช้สำหรับการเลือกทางเดินของโปรแกรมตามเงื่อนไข

### รูปแบบพื้นฐาน:

```zig
if (เงื่อนไข) {
    // โค้ดที่ทำงานเมื่อเงื่อนไขเป็นจริง
} else {
    // โค้ดที่ทำงานเมื่อเงื่อนไขเป็นเท็จ
}
```

### ตัวอย่าง:

```zig
const x = 10;
if (x > 5) {
    print("x มากกว่า 5\n", .{});
} else {
    print("x น้อยกว่าหรือเท่ากับ 5\n", .{});
}
```

### คุณสมบัติพิเศษของ if ใน Zig:

1. **Expression, ไม่ใช่แค่ statement** - `if` ใน Zig สามารถคืนค่าได้:

```zig
const result = if (x > 5) "มากกว่า 5" else "น้อยกว่าหรือเท่ากับ 5";
```

2. **ต้องใส่วงเล็บให้กับเงื่อนไขเสมอ** - แม้ว่าจะเป็นเงื่อนไขง่ายๆ:

```zig
if (true) { /* ... */ } // ถูกต้อง
if true { /* ... */ }   // ผิด - จะเกิด compilation error
```

3. **ต้องมี boolean condition** - ไม่เหมือนภาษาอื่นที่อาจยอมรับค่าอื่นๆ:

```zig
if (1) { /* ... */ }  // ผิด - 1 ไม่ใช่ boolean
if (true) { /* ... */ }  // ถูกต้อง
```

## 2. for loops

`for` ใช้สำหรับวนลูปผ่านข้อมูลแบบตาราง (array) หรือ slice

### รูปแบบพื้นฐาน:

```zig
for (ชุดข้อมูล, อินเด็กซ์?) |ค่าแต่ละรายการ, ตำแหน่ง?| {
    // โค้ดที่ทำซ้ำสำหรับแต่ละรายการ
}
```

### ตัวอย่าง:

```zig
// วนลูปผ่านค่าทุกตัวในอาร์เรย์
const items = [_]i32{ 1, 2, 3, 4, 5 };
for (items) |item| {
    print("ค่า: {d}\n", .{item});
}

// วนลูปพร้อมกับเก็บตำแหน่ง (index)
for (items, 0..) |item, i| {
    print("items[{d}] = {d}\n", .{i, item});
}
```

### คุณสมบัติพิเศษของ for ใน Zig:

1. **Multi-object for loop** - วนลูปหลายตารางพร้อมกัน:

```zig
const a = [_]i32{ 1, 2, 3 };
const b = [_]i32{ 4, 5, 6 };
for (a, b) |a_val, b_val| {
    print("{d} + {d} = {d}\n", .{a_val, b_val, a_val + b_val});
}
```

2. **ใช้ `_` เพื่อข้ามค่าที่ไม่ต้องการใช้**:

```zig
for (items, 0..) |_, i| {
    print("ตำแหน่งที่ {d}\n", .{i});
}
```

## 3. while loops

`while` ใช้สำหรับการทำงานซ้ำตราบใดที่เงื่อนไขยังคงเป็นจริง

### รูปแบบพื้นฐาน:

```zig
while (เงื่อนไข) {
    // โค้ดที่ทำงานซ้ำตราบใดที่เงื่อนไขเป็นจริง
}
```

### ตัวอย่าง:

```zig
var i: usize = 0;
while (i < 3) {
    print("i = {d}\n", .{i});
    i += 1;
}
```

### คุณสมบัติพิเศษของ while ใน Zig:

1. **Continue Expression** - ทำสิ่งนี้ก่อนจะวนลูปใหม่:

```zig
var i: usize = 0;
while (i < 3) : (i += 1) {
    print("i = {d}\n", .{i});
}
```

2. **Break Condition** - เงื่อนไขเพิ่มเติมสำหรับการหยุดลูป:

```zig
var sum: u32 = 0;
var i: u32 = 0;
while (i < 10) : (i += 1) {
    sum += i;
    if (sum > 20) break;
}
```

3. **else clause** - ทำงานเมื่อลูปจบโดยไม่เจอ `break`:

```zig
var i: u32 = 0;
while (i < 10) : (i += 1) {
    if (i == 5) break;
} else {
    // ทำงานเมื่อไม่เจอ break (จะไม่ทำงานในกรณีนี้)
    print("ลูปจบโดยไม่เจอ break\n", .{});
}
```

## 4. switch

`switch` ใช้เพื่อเลือกการทำงานตามค่าของตัวแปร

### รูปแบบพื้นฐาน:

```zig
switch (ตัวแปร) {
    case1 => การทำงาน1,
    case2 => การทำงาน2,
    case3 => การทำงาน3,
    else => การทำงานเมื่อไม่ตรงกับ case ใดๆ,
}
```

### ตัวอย่าง:

```zig
const value = 2;
switch (value) {
    1 => print("หนึ่ง\n", .{}),
    2 => print("สอง\n", .{}),
    3 => print("สาม\n", .{}),
    else => print("อื่นๆ\n", .{}),
}
```

### คุณสมบัติพิเศษของ switch ใน Zig:

1. **Exhaustive** - ต้องครอบคลุมทุกกรณีที่เป็นไปได้:

```zig
const Direction = enum { north, south, east, west };
const dir = Direction.east;

switch (dir) {
    .north => print("ทิศเหนือ\n", .{}),
    .south => print("ทิศใต้\n", .{}),
    .east => print("ทิศตะวันออก\n", .{}),
    .west => print("ทิศตะวันตก\n", .{}),
    // ไม่จำเป็นต้องมี else เพราะครอบคลุมทุกกรณีแล้ว
}
```

2. **หลาย case ในบรรทัดเดียว**:

```zig
switch (value) {
    1, 2, 3 => print("1, 2, หรือ 3\n", .{}),
    4...10 => print("4 ถึง 10\n", .{}),
    else => print("อื่นๆ\n", .{}),
}
```

3. **เป็น expression** - สามารถคืนค่าได้:

```zig
const description = switch (value) {
    1 => "หนึ่ง",
    2 => "สอง",
    3 => "สาม",
    else => "อื่นๆ",
};
```

## 5. defer

`defer` ใช้เพื่อกำหนดการทำงานที่จะทำเมื่อออกจากขอบเขตปัจจุบัน (scope)

### รูปแบบพื้นฐาน:

```zig
defer {
    // โค้ดที่จะทำงานเมื่อออกจากขอบเขตปัจจุบัน
}
```

### ตัวอย่าง:

```zig
{
    print("เริ่มทำงาน\n", .{});
    defer print("จบการทำงาน\n", .{});
    print("กำลังทำงาน\n", .{});
}
// แสดงผล:
// เริ่มทำงาน
// กำลังทำงาน
// จบการทำงาน
```

### คุณสมบัติพิเศษของ defer ใน Zig:

1. **เรียงลำดับแบบ LIFO (Last In, First Out)**:

```zig
{
    defer print("1\n", .{});
    defer print("2\n", .{});
    defer print("3\n", .{});
}
// แสดงผล:
// 3
// 2
// 1
```

2. **ใช้เพื่อทำความสะอาดทรัพยากร**:

```zig
fn readFile() !void {
    const file = try std.fs.cwd().openFile("test.txt", .{});
    defer file.close(); // ปิดไฟล์เมื่อออกจากฟังก์ชัน
  
    // อ่านไฟล์...
    // อาจเกิด error ในส่วนนี้ แต่ defer ยังคงทำงาน
}
```

## 6. ตัวอย่างการใช้งานแบบผสมผสาน

### การทำงานแบบผสมผสานระหว่าง if, for, while, และ switch:

```zig
pub fn main() void {
    const numbers = [_]i32{ 1, 5, 2, 8, 3, 7 };
    var sum: i32 = 0;
  
    for (numbers) |num| {
        switch (num) {
            1...3 => {
                // ตัวเลขเล็ก (1-3) คูณสอง
                sum += num * 2;
                print("เพิ่ม {d}*2 = {d} เข้าไป\n", .{num, num * 2});
            },
            4...6 => {
                // ตัวเลขกลาง (4-6) บวกห้า
                sum += num + 5;
                print("เพิ่ม {d}+5 = {d} เข้าไป\n", .{num, num + 5});
            },
            else => {
                if (num > 7) {
                    // ตัวเลขมากกว่า 7 ไม่นับ
                    print("ข้าม {d} (มากกว่า 7)\n", .{num});
                    continue;
                }
                // ตัวเลขอื่นๆ นับปกติ
                sum += num;
                print("เพิ่ม {d} เข้าไป\n", .{num});
            },
        }
    }
  
    print("ผลรวมทั้งหมด: {d}\n", .{sum});
  
    // แสดงผลสรุป
    if (sum > 20) {
        print("ผลรวมมากกว่า 20\n", .{});
    } else if (sum > 10) {
        print("ผลรวมมากกว่า 10 แต่ไม่เกิน 20\n", .{});
    } else {
        print("ผลรวมไม่เกิน 10\n", .{});
    }
}
```

## สรุป

Control flow ใน Zig มีความยืดหยุ่นและมีประสิทธิภาพ มีจุดเด่นดังนี้:

1. **Expression-based** - `if`, `switch` สามารถคืนค่าได้
2. **Exhaustiveness checking** - ตรวจสอบว่าครอบคลุมทุกกรณีหรือไม่
3. **Explicit** - เงื่อนไขต้องเป็น boolean เท่านั้น
4. **Powerful defer** - ช่วยในการจัดการทรัพยากรและทำความสะอาด
5. **Flexible loops** - `for` และ `while` มีรูปแบบที่หลากหลาย

การเข้าใจและใช้ control flow อย่างมีประสิทธิภาพจะช่วยให้คุณเขียนโค้ด Zig ที่สะอาด ปลอดภัย และทำงานได้ตามที่ต้องการ
